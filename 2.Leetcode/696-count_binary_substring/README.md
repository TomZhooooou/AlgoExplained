#### [696. 计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/)

给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。

```
输入: "00110011"
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
```



由题意可以看出 ，与最长连续的01相关，如果是000111那么结果将有01，0011，000111符合条件，此时结果为最长连续的0&1的值。

设置程序计算当前 0 或 1 连续相同的个数 count

prev计数当前的上一次的个数

如果遇见数字变化，则结果的值直接加上当前个数和上一个连续最长的个数的最小值min(count, prev) 即为最长连续01的值

最后加一次便是最后的01的个数

也可以通过加一个哨兵，减少最后那次的运算。

```c++
int countBinarySubstrings(string s) {
        int count = 1, sumres = 0, prev = 0;
  			//s+= '-';
        for(int i =1; i< s.size(); i++)
        {
            if(s[i] == s[i-1])
            {
                count++;
            }else{
                sumres += min(prev, count);
                prev = count;
                count = 1;
            }
        }
        //  return sumres;
        return sumres + min(prev, count) ;
    }
```



  